# Rust宏

宏，其实本质上就是一种用来编写代码的代码，在宏编程的概念里，代码也是一种数据，在支持宏编程的语言中，我们可以在编译阶段辅助编译器来按照我们的设计目标操纵这些由代码构成的数据。在有的编程语言里，这种技术也被称作产生式编程（Generative Programming）或元编程（Meta Programming）。在合适的场合使用Rust宏，可利用元编程显著降低重复代码数量并提高程序的性能，同时保持良好的可维护性。尤其是考虑到Rust语言特性还在持续迭代中，目前还远没完备到无可挑剔的地步。宏在一定程度上就有机会扩展编译器支持一些比较灵活的功能。当然，可能对大多数常规开发场景而言，实际在工程实践定义自己的宏并不常见，也不是必须的，甚至在一些极端情况下（尤其是用其它语法工具更合适的时候）对宏编程的滥用还可能会一些副作用。尽管如此，综合考虑宏编程的强大能力，个人还是建议Rust程序员要尽量掌握这个强大的武器。

简单的说，Rust的宏可以分为以下几类：
- 声明宏（macro_rules!）：比较接近C/C++的基于模板展开的宏编程，利用Rust模式匹配语法实现，大大提升了宏语义的严谨性和实用性。
- 过程宏：操作编译器来修改和生成所需的TokenStream和AST，可实现比声明宏模板语法更灵活和强大的宏功能的注入。
  - 派生宏（proc_macro_derive!）：最常见，可以通过元编程的形式，向一个struct、enum等数据类型注入新的特性（前提是这个trait可以存在一个通用实现）
  - 属性宏（proc_macro_attribute!）：很接近AOP编程里的Aspect注入或注解，其实`#[inline]`和`#[derive]`本身也都是一个属性宏
  - 类函数宏（proc_macro!）：实际效果和声明宏类似，可以定义一个新的像函数一样使用的宏，但由于支持更灵活的元编程，可实现纯靠模板展开无法支持的复杂逻辑

其实，我们平时在Rust代码里还是会遇到很多宏指令的，一个简单粗暴的鉴别方法是：
- 在代码里如果看见...!结尾的类函数用法的语句，那么很大概率是一个声明宏
- 在代码里如果看见#[...]开头的内容，那么大概率是一个过程宏

## 宏的工作机制

无论声明宏还是过程宏，所有的宏实际上都是在编译阶段由编译器解释、执行和处理的，而其它普通代码则是在运行时被执行的。普通代码的输出是各种各样的正常业务数据，而宏代码的输出实际上是一段代码（或代码的各种等价中间表示）。

```text
┌─────────────┐             ┌───────────────────┐               ┌───────────────────┐               ┌────────────────────┐      
│   (crate)   │             │                   │               │      (rustc)      │               │                    │    
│             │             │ Procedural Macros │               │     Code Text     |               │ Declarative Macros │ 
│             |             |         │         |               │         │         │               │          │         │ 
│             │             │         │         │               │         │         │               │          │         │    
│             │             │         ↓         │               │         ↓         │               │          ↓         │   
│ proc_macro ──────────────────→ TokenStream    │       ┌──────────→ TokenStream ←───── expand ────────── TokenStream    │   
│      │      │             │         │         │       │       │         │         │               │                    │    
│      │      |             │         │         │       │       │         │         │               └────────────────────┘    
│      ↓      │             │         ↓         │       │       │         ↓         │    
│ proc_macro2 ────────────────→ (proc_macro2)   │       │       |        AST        │
│             │             │    TokenStream    │       │       │         │         │   
│             │             │         │         │    expand     │         │         │   
│             │             │         │         │       │       │         ↓         │   
│             │             │         ↓         │       │       │        HIR        │   
│     syn ─────────────────────────→ AST        │       │       │         │         │   
│             │             │         │         │       │       │         │         │   
│             │             │         │         │       │       │         ↓         │   
│             │             │         ↓         │       │       │        MIR        │   
│    quote ────────────────────→ TokenStream ───────────┘       │         │         │   
│             │             │                   │               │         │         │   
└─────────────┘             └───────────────────┘               │         ↓         │   
                                                                │      LLVM IR      |
                                                                │         │         │   
                                                                └─────────│─────────┘   
                                                                          │  
                                                                          │
                                                                ┌─────────│─────────┐
                                                                │         ↓         │   
                                                                │      machine      │
                                                                | instruction codes | 
                                                                │       (LLVM)      │
                                                                |                   │   
                                                                └───────────────────┘   
```

从上图可以看出，Rust的宏的工作方式其实和C/C++的元编程是不一样的。
- C语言里的宏实际上是一个相对独立和简单的文本预处理过程，我们可以认为在Tokenization前就已经运行宏模板展开了。
- C++的模板本身就是一种图灵完备的编程语言，因此可以用来做很多复杂的产生式编程类的事情。

无论是声明宏还是过程宏，宏展开实际上都是在从Token Stream翻译生成AST这一步完成的。
- 当编译器在TokenStream里遇到一个宏，那么就会在合适的时机根据具体的宏代码来把它展开成对应的AST。
- 声明宏和过程宏的主要差别是`impl`部分，也就是需要被替换或插入的TokenStream的定义方式不同：
  - 声明宏的`impl`，其TokenStream是通过代码模板（macro as example）和模式匹配来定义的
  - 过程宏的`impl`，其TokenStream是通过编译期被执行的Rust代码调用syn、quote、proc-macro等crate通过编程方式产生的

Rust的宏展开是支持嵌套的。如果一个宏展开后的TokenStream仍然包括宏语法，那么Rust编译器还可以继续以嵌套和递归形式再次进行宏展开。当然，为了保证编译效率，这种嵌套和递归的深度会有一个上限控制，目前默认的最大嵌套深度为128。

## 宏的使用

宏的使用从代码形式上看主要有两种形式：

- 属性：形如`#[$macro($arg)]`和`#![$macro($arg)]`
  - 作为一个条目、表达式、语句的注解：Java和C#里一般叫注解（Annotation），python里一般叫装饰器（Decorator）
  - 编译器负责在编译时根据属性的具体内容，把它们展开和替换为对应的宏代码

- 函数：形如`$macro! $arg`
  - 使用起来很接近普通函数，但可支持变长参数和参数类型重载
  - 编译器负责在编译时把它们翻译成对应的宏代码，展开和替换在合适的位置

## 宏的调试

在宏的开发调试过程中，我们可能会需要看到宏展开后的代码是否符合预期，比较最常用的方法有两个：

### cargo-expand

[`cargo-expand`](https://github.com/dtolnay/cargo-expand)是一个需要单独安装的cargo工具。它本质上就是一个包装器，实际执行的命令是：`$ cargo rustc --profile=check -- -Zunpretty=expanded`。

安装命令如下：

``` bash
rustup component add rustfmt
cargo install cargo-expand
```

运行命令如下：

``` bash
cargo expand
cargo expand path::to::module
```

### Rust Playgournd

https://play.rust-lang.org/


## 声明宏

声明宏虽然功能和用法与C/C++中的#define类似，但Rust编译器实现方式的不同，因此相比较C/C++的宏还是有很大进步的，也很好的扩展和弥补了Rust语言当前的一些限制和不足：
- 通过元类型的精准模式匹配，可在编译阶段提供对声明宏的语法检查，大大提高了语法严谨性
- 通过模式匹配中的变长元，可实现类似变长参数函数的效果，比如常见的println!、vec!等就是这样实现的
- 通过模式匹配的多路径匹配。可提供近似参数类型重载的语义（要注意处理歧义）

<!-- TODO: 宏参数的类型 -->
<!-- TODO: 模式匹配与重载 -->
<!-- TODO: 可变长参数 -->
<!-- TODO: 声明宏的递归定义 -->

## 过程宏

和声明宏不同，过程宏必须定义在一个独立的crate中，也就是不允许在一个crate里既定义过程宏、又使用过程宏。声明宏比过程宏要简单一些，因为声明宏内并不存在需要编译器去编译的代码，而只需要靠词法分析器就可以正常执行的模式匹配和文本展开。当声明宏的定义和使用在同一个crate里时，Rust编译器仍然可以在一次编译过程中的词法分析阶段先对声明宏做模式匹配，然后再进行整个crate的剩余编译过程。过程宏本身就是由Rust代码来实现宏展开逻辑的，因此这个宏展开逻辑本身就本身就需要一轮完整的Rust代码编译。如果我们不做任何限制和特殊处理，当一个crate里即包含宏的使用和宏的定义时，编译器编译它的时候就会制造一个先有鸡还是先有蛋的类似死循环一样的递归嵌套陷阱。

不排除Rust未来会做一些调整而取消这个限制，比如在编译时把过程宏的编译当作每个crate的编译中都必然经历的特殊阶段，把过程宏当作一个crate里的需要单独和提前编译好的特殊子模块。不过就现在的Rust编译器而言，我们还是要把过程宏视为小型的编译器插件，需要把它独立提取出来成为一个自成体系的lib crate。当然，上面这些限制都是从编译器角度来说的，对源代码管理和crate发行来说，我们还是可以通过一些技巧在统一的源码repo里管理过程宏crate的代码，也可通过`re-export`来隐藏和合并crate，无需真的在crate.io上发行这个独立的过程宏crate。如果对这方面的细节实现有兴趣，可自行参考serde等著名的第三方库的内部实现和包发行的管理。

过程宏的crate的编译也是通过一个独立的`cargo.toml`文件来定义的。在这个`cargo.toml`里，需要显式指明其crate类型是一个定义过程宏的lib。

```toml
[lib]
proc-macro = true
```

### 派生宏

<!-- TODO -->

### 属性宏

<!-- TODO -->

### 类函数宏

<!-- TODO -->

### 编写过程宏的常用库

以下是一些编写过程宏常用的crate
- proc_macro：Rust编译器会对接这个库来定义和生成过程宏的返回结果`TokenStream`。大多数情况下，我们实际的过程宏代码并不会直接使用这个库所定义的`TokenStream`，而是会访问`proc_macro2`里定义的`TokenSteam`，再用它提供的`into()`方法做一个类型转换来跟Rust编译器协作产生正确的可以被编译器认识的`TokenStream`输出。
- proc_macro2：真正使用的过程宏的`TokenStream`定义库。
- syn：可以把`TokenStream`解析为AST语法树。
- quote：支持一种类似声明宏的方式，用`quote!{}`宏把内部的字面量代码翻译为过程宏开发所需的`TokenStream`。
- darling：?

## 宏的卫生性（hygienic）

`hygienic`这个词被翻译为卫生性，其实有点拗口。如果更通俗一点去理解，可以翻译为宏的抗污染性，也就是宏的内部实现和外部上下文环境之间的隔离性，比如宏的内部实现会不会被上下文环境污染和宏的外部上下文环境会不会被宏的内部实现所破坏。

如果编程语言只把宏当作预处理阶段的一种文本替换机制，把抗污染性的责任完全外包给编写宏的程序员，那么在很多非刻意情形下的宏展开，就会得到许多意料之外的结果，比如C语言里比较经典的MAX宏，往往需要被写成下面的样子。

``` c
#define MAX(a,b) ((a)>(b)?(a):(b))
```

在Rust宏的设计里，编译器做了很多工作，来尽可能保证宏的卫生性。这是一个从Rust红宝书里看到的一个试图制造混乱的声明宏。声明宏`make_local!`里重新绑定了本地变量local并把它的值赋为0，如果宏的卫生性被破坏，那么`assert_eq!`处的断言将失败。

``` rs
#[macro_export]
macro_rules! make_local
{
    () =>
    {
        let local = 0;
    };
}

fn main()
{
    let local = 42;
    make_local!();
    assert_eq!(local, 42);
}
```

而实际上，Rust编译器做声明宏的展开时却能在`assert_eq!`时准确的知道该使用宏实现外所定义的`local`变量，而非被宏重新绑定并赋值为0的`local`变量，因此断言并不会失败。Rust编译器进行词法翻译的时候，实际上会给每个TokenStream里的Token指定一个Span，用来标识它所在的源代码码的区域。因此，`make_local!`宏里重绑定的变量`local`和`main`里定义的变量`local`，它们的span是不一样的。而`assert_eq!`所关联的`local`变量，会被编译器理解为需要和`main`里定义的`local`变量span相同。从上面这个例子可以看出，所谓宏的卫生性，其实就是要以明确的、易于被程序员理解、不会造成歧义和混乱的方式来允许和禁止宏展开时对上下文环境的访问，也就是Span到底要通过何种规则在编译期确定。

## 学习资源

强烈推荐Veykrill和Daniel撰写的[The Little Book of Rust Macros](https://github.com/veykril/tlborm)，以下是在线阅读版本的访问链接：
- [英文版](https://veykril.github.io/tlborm/)
- [中文版](https://zjp-cn.github.io/tlborm/introduction.html)

## 后话

需特别说明的是，Rust的宏语法实际上还在进行一些调整与改进，其中一个比较主要的非兼容性改动是一个被称做[Macros 2.0](https://veykril.github.io/tlborm/decl-macros/macros2.html)的RFC，详细情况如下：
- [RFC 1584](https://github.com/rust-lang/rfcs/blob/master/text/1584-macros.md)
- [Tracking 39412](https://github.com/rust-lang/rust/issues/39412)

尽管有这些新的动向，但总体而言影响并不大，正常书写的宏代码不需要很大的改动未来就可以适配。